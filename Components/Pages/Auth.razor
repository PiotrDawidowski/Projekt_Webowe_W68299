@page "/Auth"
@using System.Net.Http
@using System.Net.Http.Json
@using System.Globalization
@using Microsoft.AspNetCore.Components.Authorization
@using ProjektKrypto2.Components.Models
@using ProjektKrypto2.Data
@using Microsoft.EntityFrameworkCore
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ApplicationDbContext DbContext
@rendermode InteractiveServer

<PageTitle>Auth</PageTitle>

<h3>Kup kryptowaluty</h3>

@if (!isUserAuthenticated)
{
    <p><strong>Zaloguj się, aby kupować kryptowaluty.</strong></p>
}
else
{
    <p>Twoje saldo: <strong>@balance.ToString("C", CultureInfo.GetCultureInfo("en-US"))</strong></p>

    <div class="mb-3">
        <label>Wybierz kryptowalutę:</label>
        <select @bind="selectedCryptoSymbol" class="form-select">
            <option value="">-- Wybierz --</option>
            @foreach (var crypto in cryptos)
            {
                <option value="@crypto.Symbol">@crypto.Name (@crypto.Symbol)</option>
            }
        </select>
    </div>

    <div class="mb-3">
        <label>Wpisz ilość:</label>
        <input type="number" class="form-control" @bind="quantity" min="0.01" step="0.01" />
    </div>

    <button class="btn btn-primary" @onclick="BuyCrypto">Kup</button>

    @if (!string.IsNullOrEmpty(transactionMessage))
    {
        <p class="mt-2">@transactionMessage</p>
    }
}

<h3 style="margin-top: 20px;">Lista dostępnych kryptowalut</h3>

<p>Ostatnia aktualizacja: @lastUpdated.ToString("HH:mm:ss")</p>

@if (!cryptos.Any())
{
    <p>Ładowanie danych...</p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Rank</th>
                <th>Logo</th>
                <th>Nazwa</th>
                <th>Symbol</th>
                <th>Cena (USD)</th>
                <th>Zmiana 24h (%)</th>
                <th>Wolumen 24h (USD)</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var crypto in cryptos)
            {
                var priceChangePercent = ParseDecimal(crypto.ChangePercent24Hr);
                <tr>
                    <td>@crypto.Rank</td>
                    <td>
                        <img src="@crypto.GetIconUrl()"
                             alt="@crypto.Symbol"
                             width="32" height="32"
                             onerror="this.onerror=null; this.src='sample-icon.png';">
                    </td>
                    <td>@crypto.Name</td>
                    <td>@crypto.Symbol</td>
                    <td>@(ParseDecimal(crypto.PriceUsd).ToString("N2"))</td>
                    <td style="color: @(priceChangePercent > 0 ? "green" : (priceChangePercent < 0 ? "red" : "black"))">
                        @(priceChangePercent.ToString("N2"))
                    </td>
                    <td>@(ParseDecimal(crypto.VolumeUsd24Hr).ToString("N0"))</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<Crypto> cryptos { get; set; } = new();
    private DateTime lastUpdated = DateTime.Now;
    private CancellationTokenSource cts = new();

    private string selectedCryptoSymbol = "";
    private decimal quantity = 0;
    private string transactionMessage = "";
    private bool isUserAuthenticated = false;
    private decimal balance = 0;
    private string? userId = null;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        isUserAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;
        userId = authState.User.FindFirst(c => c.Type == "sub")?.Value;

        if (isUserAuthenticated && !string.IsNullOrEmpty(userId))
        {
            await LoadUserBalance();
        }

        await FetchCryptoData();
        StartAutoRefresh();
    }

    private async Task LoadUserBalance()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var userId = authState.User.FindFirst(c => c.Type == "sub")?.Value;

        if (!string.IsNullOrEmpty(userId))
        {
            var dbUser = await DbContext.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == userId);

            if (dbUser != null)
            {
                balance = dbUser.BalanceUsd;
            }
        }
    }


    private void StartAutoRefresh()
    {
        _ = Task.Run(async () =>
        {
            while (!cts.Token.IsCancellationRequested)
            {
                await FetchCryptoData();
                await Task.Delay(TimeSpan.FromSeconds(10), cts.Token);
            }
        }, cts.Token);
    }

    private async Task FetchCryptoData()
    {
        try
        {
            using var httpClient = HttpClientFactory.CreateClient();
            var url = "https://api.coincap.io/v2/assets?limit=30";
            var response = await httpClient.GetFromJsonAsync<CryptoResponse>(url, cts.Token);

            if (response?.Data != null && response.Data.Any())
            {
                cryptos = response.Data.ToList();
                lastUpdated = DateTime.Now;

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd pobierania danych: {ex.Message}");
        }
    }

    private async Task BuyCrypto()
    {
        if (!isUserAuthenticated || userId == null)
        {
            transactionMessage = "Musisz być zalogowany.";
            return;
        }

        if (string.IsNullOrEmpty(selectedCryptoSymbol) || quantity <= 0)
        {
            transactionMessage = "Niepoprawna ilość.";
            return;
        }

        var crypto = cryptos.FirstOrDefault(c => c.Symbol == selectedCryptoSymbol);
        if (crypto == null)
        {
            transactionMessage = "Wybrana kryptowaluta nie istnieje.";
            return;
        }

        var dbUser = await DbContext.Users.FindAsync(userId);
        if (dbUser == null)
        {
            transactionMessage = "Błąd użytkownika.";
            return;
        }

        decimal price = ParseDecimal(crypto.PriceUsd) * quantity;

        if (dbUser.BalanceUsd >= price)
        {
            dbUser.BalanceUsd -= price;

            var walletEntry = new CryptoWallet
                {
                    UserId = userId,
                    CryptoSymbol = crypto.Symbol,
                    CryptoName = crypto.Name,
                    Quantity = quantity,
                    PriceUsd = ParseDecimal(crypto.PriceUsd)
                };

            await DbContext.CryptoWallets.AddAsync(walletEntry);
            await DbContext.SaveChangesAsync();

            await LoadUserBalance();
            transactionMessage = $"Zakupiono {quantity} {crypto.Symbol} za {price} USD!";
        }
        else
        {
            transactionMessage = "Za mało środków!";
        }
    }

    private decimal ParseDecimal(string value)
    {
        return decimal.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out var dec) ? dec : 0;
    }

    public void Dispose()
    {
        cts.Cancel();
        cts.Dispose();
    }
}
